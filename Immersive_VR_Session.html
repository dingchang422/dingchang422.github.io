<!DOCTYPE html>
<!-- saved from url=(0071)https://immersive-web.github.io/webxr-samples/immersive-vr-session.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style>
    @font-face {
        font-family: 'Karla';
        font-style: normal;
        font-weight: 400;
        src: local('Karla'), local('Karla-Regular'),
             url(https://fonts.gstatic.com/s/karla/v5/31P4mP32i98D9CEnGyeX9Q.woff2) format('woff2');
        unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
    }
    @font-face {
        font-family: 'Karla';
        font-style: normal;
        font-weight: 400;
        src: local('Karla'), local('Karla-Regular'),
             url(https://fonts.gstatic.com/s/karla/v5/Zi_e6rBgGqv33BWF8WTq8g.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074,
                       U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
    }

    button.webvr-ui-button {
        font-family: 'Karla', sans-serif;

        border: rgb(80,168,252) 2px solid;
        border-radius: 2px;
        box-sizing: border-box;
        background: none;

        height: 55px;
        min-width: 175.99999999999997px;
        display: inline-block;
        position: relative;

        cursor: pointer;
        transition: border 0.5s;
    }

    button.webvr-ui-button:focus {
      outline: none;
    }

    /*
    * Logo
    */

    .webvr-ui-logo {
        width: 55px;
        height: 55px;
        position: absolute;
        top:0px;
        left:0px;
        width: 51px;
        height: 51px;
    }
    .webvr-ui-svg {
        fill: rgb(80,168,252);
        margin-top: 18.166666666666668px;
        margin-left: 18.333333333333332px;
    }
    .webvr-ui-svg-error {
        fill: rgb(80,168,252);
        display:none;
        margin-top: 14.092592592592595px;
        margin-left: 18.333333333333332px;
    }


    /*
    * Title
    */

    .webvr-ui-title {
        color: rgb(80,168,252);
        position: relative;
        font-size: 18.333333333333332px;
        padding-left: 57.75px;
        padding-right: 18.333333333333332px;
        transition: color 0.5s;
    }

    /*
    * disabled
    */

    button.webvr-ui-button[disabled=true] {
        opacity: 0.5;
    }

    button.webvr-ui-button[disabled=true] > .webvr-ui-logo > .webvr-ui-svg {
        display:none;
    }

    button.webvr-ui-button[disabled=true] > .webvr-ui-logo > .webvr-ui-svg-error {
        display:initial;
    }

    /*
    * error
    */

    button.webvr-ui-button[error=true] {
        animation: errorShake 0.4s;
    }

    @keyframes errorShake {
      0% { transform: translate(1px, 0) }
      10% { transform: translate(-2px, 0) }
      20% { transform: translate(2px, 0) }
      30% { transform: translate(-2px, 0) }
      40% { transform: translate(2px, 0) }
      50% { transform: translate(-2px, 0) }
      60% { transform: translate(2px, 0) }
      70% { transform: translate(-2px, 0) }
      80% { transform: translate(2px, 0) }
      90% { transform: translate(-1px, 0) }
      100% { transform: translate(0px, 0) }
    }
  </style>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="icon" type="image/png" sizes="32x32" href="https://immersive-web.github.io/webxr-samples/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://immersive-web.github.io/webxr-samples/favicon-96x96.png">
    <link rel="stylesheet" href="./Immersive VR Session_files/common.css">

    <title>Immersive VR Session</title>
  </head>
  <body>
    <header>
      <details open="">
        <summary>Immersive VR Session</summary>
        <p>
          This sample demonstrates how to use an 'immersive-vr' XRSession to
          present a simple WebGL scene to an XR device. The scene is not
          rendered to the page.
          <a class="back" href="https://immersive-web.github.io/webxr-samples/">Back</a>
        </p>
      </details>
    <button class="webvr-ui-button" disabled="true" title="No XR headset found.">
          <div class="webvr-ui-title" style="display: initial;">VR NOT FOUND</div>
          <div class="webvr-ui-logo"><svg class="webvr-ui-svg" version="1.1" x="0px" y="0px" width="22.814814814814813px" height="14.666666666666666px" viewBox="0 0 28 18" xml:space="preserve">
        <path d="M26.8,1.1C26.1,0.4,25.1,0,24.2,0H3.4c-1,0-1.7,0.4-2.4,1.1C0.3,1.7,0,2.7,0,3.6v10.7
        c0,1,0.3,1.9,0.9,2.6C1.6,17.6,2.4,18,3.4,18h5c0.7,0,1.3-0.2,1.8-0.5c0.6-0.3,1-0.8,1.3-1.4l
        1.5-2.6C13.2,13.1,13,13,14,13v0h-0.2 h0c0.3,0,0.7,0.1,0.8,0.5l1.4,2.6c0.3,0.6,0.8,1.1,1.3,
        1.4c0.6,0.3,1.2,0.5,1.8,0.5h5c1,0,2-0.4,2.7-1.1c0.7-0.7,1.2-1.6,1.2-2.6 V3.6C28,2.7,27.5,
        1.7,26.8,1.1z M7.4,11.8c-1.6,0-2.8-1.3-2.8-2.8c0-1.6,1.3-2.8,2.8-2.8c1.6,0,2.8,1.3,2.8,2.8
        C10.2,10.5,8.9,11.8,7.4,11.8z M20.1,11.8c-1.6,0-2.8-1.3-2.8-2.8c0-1.6,1.3-2.8,2.8-2.8C21.7
        ,6.2,23,7.4,23,9 C23,10.5,21.7,11.8,20.1,11.8z"></path>
    </svg><svg class="webvr-ui-svg-error" x="0px" y="0px" width="22.814814814814813px" height="22.814814814814813px" viewBox="0 0 28 28" xml:space="preserve">
        <path d="M17.6,13.4c0-0.2-0.1-0.4-0.1-0.6c0-1.6,1.3-2.8,2.8-2.8s2.8,1.3,2.8,2.8s-1.3,2.8-2.8,2.8
        c-0.2,0-0.4,0-0.6-0.1l5.9,5.9c0.5-0.2,0.9-0.4,1.3-0.8
        c0.7-0.7,1.1-1.6,1.1-2.5V7.4c0-1-0.4-1.9-1.1-2.5c-0.7-0.7-1.6-1-2.5-1
        H8.1 L17.6,13.4z"></path>
        <path d="M10.1,14.2c-0.5,0.9-1.4,1.4-2.4,1.4c-1.6,0-2.8-1.3-2.8-2.8c0-1.1,0.6-2,1.4-2.5
        L0.9,5.1 C0.3,5.7,0,6.6,0,7.5v10.7c0,1,0.4,1.8,1.1,2.5c0.7,0.7,1.6,1,2.5,1
        h5c0.7,0,1.3-0.1,1.8-0.5c0.6-0.3,1-0.8,1.3-1.4l1.3-2.6 L10.1,14.2z"></path>
        <path d="M25.5,27.5l-25-25C-0.1,2-0.1,1,0.5,0.4l0,0C1-0.1,2-0.1,2.6,0.4l25,25c0.6,0.6,0.6,1.5
        ,0,2.1l0,0 C27,28.1,26,28.1,25.5,27.5z"></path>
    </svg></div>
        </button></header>
    <main style="text-align: center;">
      <p>Click 'Enter XR' to see content</p> 
    </main>
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {SkyboxNode} from './js/render/nodes/skybox.js';
      import {QueryArgs} from './js/util/query-args.js';

      // If requested, use the polyfill to provide support for mobile devices
      // and devices which only support WebVR.
      import WebXRPolyfill from './js/third-party/webxr-polyfill/build/webxr-polyfill.module.js';
      if (QueryArgs.getBool('usePolyfill', true)) {
        let polyfill = new WebXRPolyfill();
      }

      // XR globals.
      let xrButton = null;
      let xrRefSpace = null;

      // WebGL scene globals.
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.addNode(new Gltf2Node({url: 'media/gltf/space/space.gltf'}));
      scene.addNode(new SkyboxNode({url: 'media/textures/milky-way-4k.png'}));

      // Checks to see if WebXR is available and, if so, queries a list of
      // XRDevices that are connected to the system.
      function initXR() {
        // Adds a helper button to the page that indicates if any XRDevices are
        // available and let's the user pick between them if there's multiple.
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        // Is WebXR available on this UA?
        if (navigator.xr) {
          // If the device allows creation of exclusive sessions set it as the
          // target of the 'Enter XR' button.
          navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
            xrButton.enabled = supported;
          });
        }
      }

      // Called when the user selects a device to present to. In response we
      // will request an exclusive session from that device.
      function onRequestSession() {
        return navigator.xr.requestSession('immersive-vr').then(onSessionStarted);
      }

      // Called when we've successfully acquired a XRSession. In response we
      // will set up the necessary session state and kick off the frame loop.
      function onSessionStarted(session) {
        // This informs the 'Enter XR' button that the session has started and
        // that it should display 'Exit XR' instead.
        xrButton.setSession(session);

        // Listen for the sessions 'end' event so we can respond if the user
        // or UA ends the session for any reason.
        session.addEventListener('end', onSessionEnded);

        // Create a WebGL context to render with, initialized to be compatible
        // with the XRDisplay we're presenting to.
        gl = createWebGLContext({
          xrCompatible: true
        });

        // Create a renderer with that GL context (this is just for the samples
        // framework and has nothing to do with WebXR specifically.)
        renderer = new Renderer(gl);

        // Set the scene's renderer, which creates the necessary GPU resources.
        scene.setRenderer(renderer);

        // Use the new WebGL context to create a XRWebGLLayer and set it as the
        // sessions baseLayer. This allows any content rendered to the layer to
        // be displayed on the XRDevice.
        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        // Get a frame of reference, which is required for querying poses. In
        // this case an 'local' frame of reference means that all poses will
        // be relative to the location where the XRDevice was first detected.
        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;

          // Inform the session that we're ready to begin drawing.
          session.requestAnimationFrame(onXRFrame);
        });
      }

      // Called when the user clicks the 'Exit XR' button. In response we end
      // the session.
      function onEndSession(session) {
        session.end();
      }

      // Called either when the user has explicitly ended the session (like in
      // onEndSession()) or when the UA has ended the session for any reason.
      // At this point the session object is no longer usable and should be
      // discarded.
      function onSessionEnded(event) {
        xrButton.setSession(null);

        // In this simple case discard the WebGL context too, since we're not
        // rendering anything else to the screen with it.
        renderer = null;
      }

      // Called every time the XRSession requests that a new frame be drawn.
      function onXRFrame(t, frame) {
        let session = frame.session;

        // Per-frame scene setup. Nothing WebXR specific here.
        scene.startFrame();

        // Inform the session that we're ready for the next frame.
        session.requestAnimationFrame(onXRFrame);

        // Get the XRDevice pose relative to the Frame of Reference we created
        // earlier.
        let pose = frame.getViewerPose(xrRefSpace);

        // Getting the pose may fail if, for example, tracking is lost. So we
        // have to check to make sure that we got a valid pose before attempting
        // to render with it. If not in this case we'll just leave the
        // framebuffer cleared, so tracking loss means the scene will simply
        // disappear.
        if (pose) {
          let glLayer = session.renderState.baseLayer;

          // If we do have a valid pose, bind the WebGL layer's framebuffer,
          // which is where any content to be displayed on the XRDevice must be
          // rendered.
          gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);

          // Clear the framebuffer
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

          // Loop through each of the views reported by the frame and draw them
          // into the corresponding viewport.
          for (let view of pose.views) {
            let viewport = glLayer.getViewport(view);
            gl.viewport(viewport.x, viewport.y,
                        viewport.width, viewport.height);

            // Draw this view of the scene. What happens in this function really
            // isn't all that important. What is important is that it renders
            // into the XRWebGLLayer's framebuffer, using the viewport into that
            // framebuffer reported by the current view, and using the
            // projection matrix and view transform from the current view.
            // We bound the framebuffer and viewport up above, and are passing
            // in the appropriate matrices here to be used when rendering.
            scene.draw(view.projectionMatrix, view.transform);
          }
        } else {
          // There's several options for handling cases where no pose is given.
          // The simplest, which these samples opt for, is to simply not draw
          // anything. That way the device will continue to show the last frame
          // drawn, possibly even with reprojection. Alternately you could
          // re-draw the scene again with the last known good pose (which is now
          // likely to be wrong), clear to black, or draw a head-locked message
          // for the user indicating that they should try to get back to an area
          // with better tracking. In all cases it's possible that the device
          // may override what is drawn here to show the user it's own error
          // message, so it should not be anything critical to the application's
          // use.
        }

        // Per-frame scene teardown. Nothing WebXR specific here.
        scene.endFrame();
      }

      // Start the XR application.
      initXR();
    </script>
  

</body></html>